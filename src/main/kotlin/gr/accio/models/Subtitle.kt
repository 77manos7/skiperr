package gr.accio.models

import io.quarkus.hibernate.reactive.panache.kotlin.PanacheCompanionBase
import io.quarkus.hibernate.reactive.panache.kotlin.PanacheEntityBase
import io.smallrye.mutiny.Uni
import jakarta.persistence.*
import java.time.Instant
import java.util.UUID

@Entity
@Table(
    name = "subtitles",
    indexes = [
        Index(name = "idx_subtitle_video", columnList = "video_id"),
        Index(name = "idx_subtitle_language", columnList = "language"),
        Index(name = "idx_subtitle_sync_status", columnList = "sync_status"),
        Index(name = "idx_subtitle_type", columnList = "type"),
        Index(name = "idx_subtitle_path", columnList = "file_path", unique = true)
    ]
)
class Subtitle : PanacheEntityBase {

    @Id @GeneratedValue(generator = "UUID")
    var id: UUID? = null

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "video_id", nullable = false)
    lateinit var video: VideoFile

    @Column(nullable = false, length = 10)
    lateinit var language: String // ISO 639-1 code (e.g., "en", "el")

    @Column(length = 100)
    var languageDisplayName: String? = null // e.g., "English", "Greek"

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    lateinit var type: SubtitleType

    @Enumerated(EnumType.STRING)
    @Column(name = "sync_status", nullable = false)
    var syncStatus: SyncStatus = SyncStatus.NOT_SYNCED

    @Column(name = "file_path", length = 1000)
    var filePath: String? = null // Path to subtitle file (null for embedded)

    var streamIndex: Int? = null // For embedded subtitles

    var isGenerated: Boolean = false // True if generated by AI
    var isDefault: Boolean = false
    var isForced: Boolean = false

    // Quality metrics
    var confidence: Double? = null // AI confidence score (0.0-1.0)
    var lineCount: Int? = null
    var duration: Long? = null // Duration in milliseconds

    // Translation properties
    @Column(name = "translated_file_path", length = 1000)
    var translatedFilePath: String? = null // Path to translated subtitle file
    
    @Column(name = "target_language", length = 10)
    var targetLanguage: String? = null // Target language for translation
    
    @Column(name = "translation_provider", length = 50)
    var translationProvider: String? = null // Provider used for translation (e.g., "openai")

    // Processing timestamps
    var extractedAt: Instant? = null
    var translatedAt: Instant? = null
    var syncedAt: Instant? = null

    var createdAt: Instant = Instant.now()
    var updatedAt: Instant = Instant.now()

    @PreUpdate
    fun preUpdate() {
        updatedAt = Instant.now()
    }

    companion object : PanacheCompanionBase<Subtitle, UUID> {
        fun findByVideo(video: VideoFile): Uni<List<Subtitle>> =
            list("video", video)

        fun findByVideoAndLanguage(video: VideoFile, language: String): Uni<List<Subtitle>> =
            list("video = ?1 AND language = ?2", video, language)

        fun findEmbedded(): Uni<List<Subtitle>> =
            list("type = ?1", SubtitleType.EMBEDDED)

        fun findExternal(): Uni<List<Subtitle>> =
            list("type = ?1", SubtitleType.EXTERNAL)

        fun findGenerated(): Uni<List<Subtitle>> =
            list("isGenerated = true")

        fun findBySyncStatus(status: SyncStatus): Uni<List<Subtitle>> =
            list("syncStatus", status)

        fun findByLanguage(language: String): Uni<List<Subtitle>> =
            list("language", language)

        fun findNeedingSync(): Uni<List<Subtitle>> =
            list("syncStatus IN (?1, ?2)", SyncStatus.NOT_SYNCED, SyncStatus.SYNC_FAILED)

        fun countByLanguage(language: String): Uni<Long> =
            count("language", language)

        fun findByPath(filePath: String): Uni<Subtitle?> =
            find("filePath", filePath).firstResult()
    }
}

enum class SubtitleType {
    EMBEDDED,    // Subtitle track within video file
    EXTERNAL,    // Separate subtitle file (.srt, .vtt, etc.)
    GENERATED    // AI-generated subtitle
}

enum class SyncStatus {
    NOT_SYNCED,     // Not yet synchronized
    SYNCING,        // Currently being synchronized
    SYNCED,         // Successfully synchronized
    SYNC_FAILED,    // Synchronization failed
    MANUAL_SYNC     // Manually synchronized by user
}